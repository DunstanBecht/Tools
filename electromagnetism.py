#!/usr/bin/env python
# coding: utf-8

"""Source: highhopes.fr"""

    #========= IMPORTS ===================================================#

from .fields import *
from .mechanics import *

    #========= CONSTANTS =================================================#

mu_0 = Quantity(4*math.pi*10**-7, "H.m-1") # Vacuum permeability
epsilon_0 = Quantity(8.854187817*10**-12, "F.m-1") # Permittivity

    #========= POTENTIALS ================================================#

def electricPotential(solid):
    """Return the electric potential generated by 'solid'."""
    checkType([solid], Solid)
    def aux(r):
        r = sub(r, origin.cfg.position)
        return div(origin.q, mul(4*math.pi, epsilon_0, norm(r)))
    return aux

def magneticPotential(solid):
    """Return the magnetic potential generated by 'solid'."""
    checkType([solid], Solid)
    def aux(r):
        r, p = origin.cfg.inside(Quantity(r, "m")), []
        for i in range(len(origin.shp)-1):
            r_dl = add(mul((1/2), origin.shp[i]), mul((1/2), origin.shp[i+1]))
            dl, n = sub(origin.shp[i+1], origin.shp[i]), norm(sub(r, r_dl))
            if n.magnitude != 0:
                p.append(div(dl, n))
        A = mul(mu_0, 1/(4*math.pi), origin.i, add(p))
        return origin.cfg.basis.outside(A)
    return aux
                   
    #========= FIELDS ====================================================#

def electricField(origin):
    """Return the electric field according to a solid or a potential."""
    if callable(origin):
        return mul(-1, gradient(origin))
    if isinstance(origin, Solid):
        def aux(r):
            r = substraction(r, origin.cfg.position)
            n = norm(r)
            if n.magnitude == 0:
                return Quantity(Vector(0, 0, 0), "V.m-1")
            return mul(div(origin.q, mul(4*math.pi, epsilon_0, pwr(3)(n))), r)
        return aux
    raise TypeError(name(origin)+" is not a valid origin")
        
def magneticField(origin):
    """Return the magnetic field according to a solid or a potential.""" 
    if callable(origin):
        return curl(origin)
    if isinstance(origin, Solid):
        checkType([origin.shp], Path)
        def aux(r):
            r, p = origin.cfg.inside(Quantity(r, "m")), []
            for i in range(len(origin.shp)-1):
                r_dl = mul((1/2), add(origin.shp[i], origin.shp[i+1]))
                dl, a = sub(origin.shp[i+1], origin.shp[i]), sub(r, r_dl)
                n = norm(a)
                if n.magnitude != 0:
                    p.append(div(vecPro(dl, a), pwr(3)(n)))
            B = mul(mu_0, 1/(4*math.pi), origin.i, add(p))
            return origin.cfg.basis.outside(B)
        return aux
    raise TypeError(name(origin)+" is not a valid origin")

    #========= FORCES ====================================================#

def lorentzForce(solid, E, v, B):
    """Return the lorentz force applied on 'solid' by 'E' and 'B'."""
    checkType([solid], Solid)
    v = Quantity(v, "m.s-1")
    r = solid.cfg.position
    return mul(solid.q, add(E(r), vecPro(v, B(r))))
    
def magneticForce(solid, B):
    """Return the magnetic force applied on 'solid' by 'B'."""               
    checkType([solid], Solid)
    M = solid.cfg.basis.outside(solid.M)
    return gradient(scaPro(M, B))(solid.cfg.position)

def magneticTorque(solid, B):
    """Return the torque generated by the magnetic field 'B' on 'solid'."""
    checkType([solid], Solid)
    M = solid.cfg.basis.outside(solid.M)
    return vecPro(M, B(solid.cfg.position))
